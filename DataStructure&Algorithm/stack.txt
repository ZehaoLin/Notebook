
栈 (Stack, 亦或堆栈)

1.栈的概念
		
	栈是一种先进后出(First in last off, FILO/LIFO)线性数据结构。很多人叫栈为堆栈，但是堆和栈是不同的数据结构。

2.栈的实现	

栈可以用数组和链表来实现。栈的基本操作有入栈、出栈、查看栈顶、判空等。

3.栈的常见应用

栈的应用很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、
浏览器中的回退操作、编译器中的函数调用实现、表达式的计算等。

3.1 线程栈

线程栈是操作系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器。
(http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html)

3.2 Object-C和OpenGL中的“绘图上下文”

3.3 用户按下键盘过滤无效按键

3.4 算术表达式的计算(重点)

编程语言中，算术表达式有前缀、中缀、后缀之分，他们都是对算术表达式的编程语言表达、记忆方式。
举例：
	前缀表达式: - * + 3 4 5 6
 	中缀表达式: (3 + 4) * 5 - 6
	后缀表达式: 3 4 + 5 * 6 -

如上面例子所示，前中后缀表达式各不相同，其中很容易发现，中缀表达式是人在数学中所常用，且习惯的一种。
算术表达式中，主要由算术运算符和操作数组成，前中后缀表达式也是由此来区分的，也导致了表示的顺序不一样。
概念：
	前缀表达式：算术运算符在前，操作数在后，不包含括号; 为纪念波兰数学家、此表达式发明者Jan Lukasiewicz，
				此表达式也成为"波兰表达式"；
	中缀表达式：算术运算符在操作数中间，相比前后缀表达式，多了表示优先级的括号；
	后缀表达式：算术运算符在后，操作数在前，正好与前缀相反，所以也成为"逆波兰表达式"。

中缀表达式是人类最容易理解的和分析的表达方式，回忆我们对中缀表达式的运算规则：
	1.在有括号的情况下，括号优先级最高，优先计算括号内的内容；
	2.在无括号的情况下，按运算符优先级进行先后计算，先乘除，后加减；
	3.在相同优先级的情况下，从左到右计算。

各表达式的优缺点：	
在中缀表达式的计算当中，需要不断遍历找出表达式中的括号和优先级较高的运算符，并且考虑操作出现的先后，这对于
人来说是简而易举的，但是对于计算机这种一根筋，只能处理0和1的机器来说，显然太复杂了，就算是实现了，时间复杂度
也是很恐怖的，毕竟运算符和操作数不可能总是只有几个，这时候出现的前缀和后缀表达式就很有用处了，也是专门为计算机
设计的。
在前缀和后缀表达式中，计算顺序不必随着运算符和括号不断变换，而是从左到右或是从右到左顺序遍历一次，不需要考虑
括号对运算的影响，再辅之的数据结构(Stack)，可完美完成计算，大大降低了计算的时间复杂度，也符合计算机的工作方式。
前缀和后缀表达式大大提高了计算机计算的性能，但对于人来说是不易理解的，特别是对于没有编程基础的人来说，所以在
输入和输出表达式给计算机计算的时候需要进行表达式转换，中缀(输入) -> 前缀/后缀(计算) -> 结果(输出)。

表达式之间的转换、表达式的计算的辅助数据结构常用栈，也是栈的一大应用。

中缀表达式 -> 后缀表达式 [ 例子：a + b * c - (d + e) ]
	人工转换：
		1.给中缀表达式的所有运算加上括号	( (a + (b * c)) - (d + e) )
		2.将运算符放到括号后面				( (a (b c)*)+ (de)+ )-
		3.去除括号							a b c * + d e + -
		
	计算机转换(用栈辅助)：
		1.建立运算符栈(大小合适，这里只存储运算符)；
		2.从左到右遍历中缀表达式：
			如果遇到操作数，则直接输出；
			如果遇到运算符，则与栈顶的运算符比较优先级：
				若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈；
				若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为
				空，或者栈顶的运算符的优先级低于当前的运算符)。
			如果遇到括号：
				若为 "(" ，则直接入栈；
				若为 ")" ，记录，弹出所有运算符，直到在栈中找到"("，才同时把 "()" 删除。
				
中缀表达式 -> 后缀表达式 计算机转换模拟 [ 例子：a + b * c - (d + e) ]
	输出终端		运算符栈(栈底 -> 栈顶)
	a			|	
	a			|	+
	ab			|	+
	ab			|	+*
	abc			|	+*
	abc*		|	+
	abc*+		|	
	abc*+		|	-
	abc*+		|	-(
	abc*+		|	-(+
	abc*+d		|	-(+
	abc*+de		|	-(+
	abc*+de+	|	-(
	abc*+de+	|	-
	abc*+de+-	|
	
中缀表达式 -> 前缀表达式 [ 例子：a + b * c - (d + e) ]
	人工转换：
		1.给中缀表达式的所有运算加上括号	( (a + (b * c)) - (d + e) )
		2.将运算符放到括a号前面				( -(+(a *(bc)) +(de) )
		3.去除括号							- + a * b c + d e
		
	计算机转换(用栈辅助):
		1.建立运算符栈和输出栈(大小合适)，其中输出栈用于存储输出数据，完成遍历后出栈的元素顺序即为前缀表达式；
		2.从右向左遍历中缀表达式:
			如果遇到操作数，则直接输出;
			如果遇到运算符，则与栈顶的运算符比较优先级：
				若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈；
				若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为
				空，或者栈顶的运算符的优先级低于当前的运算符)。
			如果遇到括号：
				若为 ")" ，则直接入栈；
				若为 "(" ，记录，弹出所有运算符，直到在栈中找到")"，才同时把 "()" 删除。
				
中缀表达式 -> 前缀表达式 计算机转换模拟 [ 例子：a + b * c - (d + e) ]
	输出栈(栈底 -> 栈顶)		运算符栈(栈底 -> 栈顶)
							|	)
	e						|	
	e						|	)+
	ed+						|	
	ed+						|	-
	ed+c					|	-	
	ed+c					|	-*
	ed+cb					|	-
	ed+cb*					|	-
	ed+cb*					|	-+
	ed+cb*a					|	-+
	ed+cb*a+				|	-
	ed+cb*a+-				|	
	
	所以，输出的前缀表达式为-+a*bc+de。

构建表达式树
	下面将表达式和二叉树的知识结合，将后缀表达式转换为二叉树 [ 例子: a b c * + d e + - ]
		1.建立栈，大小为操作数个数，这里为5；
		2.将操作数从左到右入栈，若遇到操作符，则将前面两个元素弹出，并用当前栈顶指向形成的二叉树的根节点；
		3.最终合并二叉树。
	演示：
		1. a b c
		2. a 	|
				|
			   / \
			  b   c
		3.  		  +
					/   \
					a    *
					    / \
					   b   c
		4.  		  			  +				d e
								/   \
								a    *
									/ \
								   b   c
		5.  		  			  			  +				+
											/   \		   / \
											a    *        d   e
												/ \
											   b   c
		6.									    		  	   -
														    /    \
														   /	  \		
														  /        \
														  +			+
														/   \	   / \	 
														a    *    d   e    
															/ \		   
														   b   c	   
														   
表达式遍历的程序实现: