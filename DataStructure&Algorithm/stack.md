---
title: 数据结构与算法理论学习 -- 栈
tag: DataStructure&Algorithm
---

# 栈 (Stack)

## 1. 栈的概念
栈是一种先进后出(First in last off, FILO/LIFO)线性数据结构。很多人叫栈为堆栈，但是堆和栈是不同的数据结构。

## 2. 栈的实现	
栈可以用数组和链表来实现。栈的基本操作有入栈、出栈、查看栈顶、判空等。

## 3. 栈的常见应用
栈的应用很广泛，比如编译器中的词法分析器、Java虚拟机、软件中的撤销操作、
浏览器中的回退操作、编译器中的函数调用实现、表达式的计算等。[相关介绍深度好文推荐。](http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html)

### 3.1 线程栈
线程栈是操作系统分配的一块内存区域。通常CPU上有一个特殊的称之为堆指针的寄存器。

### 3.2 Object-C和OpenGL中的“绘图上下文”

### 3.3 用户按下键盘过滤无效按键

### 3.4 算术表达式的计算([此文重点]())

## 编程中算术表达式计算
在此主要介绍栈在编程语言中的一大用处。
编程语言中，算术表达式有前缀、中缀、后缀之分，他们都是对算术表达式的编程语言表达、记忆方式。

#### 举例：

        前缀表达式: - * + 3 4 5 6
        中缀表达式: (3 + 4) * 5 - 6
        后缀表达式: 3 4 + 5 * 6 -

如上面例子所示，前中后缀表达式各不相同，其中很容易发现，中缀表达式是人在数学中所常用，且习惯的一种。
算术表达式中，主要由算术运算符和操作数组成，前中后缀表达式也是由此来区分的，也导致了表示的顺序不一样。

#### 概念：
	前缀表达式：算术运算符在前，操作数在后，不包含括号; 为纪念波兰数学家、此表达式发明者Jan Lukasiewicz，此表达式也成为"波兰表达式"；
	中缀表达式：算术运算符在操作数中间，相比前后缀表达式，多了表示优先级的括号；
	后缀表达式：算术运算符在后，操作数在前，正好与前缀相反，所以也成为"逆波兰表达式"。

#### 传统算术表达式的运算规则
中缀表达式是人类最容易理解的和分析的表达方式，回忆我们对中缀表达式的运算规则：
	
    1.在有括号的情况下，括号优先级最高，优先计算括号内的内容；
	2.在无括号的情况下，按运算符优先级进行先后计算，先乘除，后加减；
	3.在相同优先级的情况下，从左到右计算。

#### 各表达式的优缺点
* 在中缀表达式的计算当中，需要不断遍历找出表达式中的括号和优先级较高的运算符，并且考虑操作出现的先后，这对于
人来说是简而易举的，但是对于计算机这种一根筋，只能处理0和1的机器来说，显然太复杂了，就算是实现了，时间复杂度
也是很恐怖的，毕竟运算符和操作数不可能总是只有几个，这时候出现的前缀和后缀表达式就很有用处了，也是专门为计算机
设计的。

* 在前缀和后缀表达式中，计算顺序不必随着运算符和括号不断变换，而是从左到右或是从右到左顺序遍历一次，不需要考虑
括号对运算的影响，再辅之的数据结构(Stack)，可完美完成计算，大大降低了计算的时间复杂度，也符合计算机的工作方式。
前缀和后缀表达式大大提高了计算机计算的性能，但对于人来说是不易理解的，特别是对于没有编程基础的人来说，所以在
输入和输出表达式给计算机计算的时候需要进行表达式转换，中缀(输入) -> 前缀/后缀(计算) -> 结果(输出)。

#### 例子
1.中缀表达式 -> 后缀表达式 [ 例子：a + b * c - (d + e) ]
    
    人工转换：
		1.给中缀表达式的所有运算加上括号	( (a + (b * c)) - (d + e) )
		2.将运算符放到括号后面		( (a (b c)*)+ (de)+ )-
		3.去除括号			a b c * + d e + -
		
	计算机转换(用栈辅助)：
		1.建立运算符栈(大小合适，这里只存储运算符)；
		2.从左到右遍历中缀表达式：
			如果遇到操作数，则直接输出；
			如果遇到运算符，则与栈顶的运算符比较优先级：
				若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈；
				若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为
				空，或者栈顶的运算符的优先级低于当前的运算符)。
			如果遇到括号：
				若为 "(" ，则直接入栈；
				若为 ")" ，记录，弹出所有运算符，直到在栈中找到"("，才同时把 "()" 删除。
				

计算机转换模拟 [ 例子：a + b * c - (d + e) ]
	
    输出终端		            运算符栈(栈底 -> 栈顶)
	a			|	
	a			|	+
	ab			|	+
	ab			|	+*
	abc			|	+*
    abc*		        |	+
	abc*+		        |	
	abc*+		        |	-
	abc*+		        |	-(
	abc*+		        |	-(+
	abc*+d		        |	-(+
	abc*+de		        |	-(+
	abc*+de+	        |	-(
	abc*+de+	        |	-
	abc*+de+-	        |

2.中缀表达式 -> 前缀表达式 [ 例子：a + b * c - (d + e) ]

	人工转换：
		1.给中缀表达式的所有运算加上括号	( (a + (b * c)) - (d + e) )
		2.将运算符放到括a号前面		( -(+(a *(bc)) +(de) )
		3.去除括号		        - + a * b c + d e
		
	计算机转换(用栈辅助):
		1.建立运算符栈和输出栈(大小合适)，其中输出栈用于存储输出数据，完成遍历后出栈的元素顺序即为前缀表达式；
		2.从右向左遍历中缀表达式:
			如果遇到操作数，则直接输出;
			如果遇到运算符，则与栈顶的运算符比较优先级：
				若栈为空，或者栈顶的运算符的优先级低于当前的运算符，则将当前的运算符入栈；
				若栈顶运算符的优先级不低于(高于或相同)当前的运算符，则将栈顶的运算符输出，直到出现上一种情况为止(即为：栈为
				空，或者栈顶的运算符的优先级低于当前的运算符)。
			如果遇到括号：
				若为 ")" ，则直接入栈；
				若为 "(" ，记录，弹出所有运算符，直到在栈中找到")"，才同时把 "()" 删除。

计算机转换模拟 [ 例子：a + b * c - (d + e) ]

	输出栈(栈底 -> 栈顶)		运算符栈(栈底 -> 栈顶)
				|	)
	e			|	
	e			|	)+
	ed+			|	
	ed+			|	-
	ed+c		        |	-	
	ed+c		        |	-*
	ed+cb			|	-
	ed+cb*			|	-
	ed+cb*			|	-+
	ed+cb*a			|	-+
	ed+cb*a+		|	-
	ed+cb*a+-		|	
	
	所以，输出的前缀表达式为-+a*bc+de。


3.构建表达式树

	下面将表达式和二叉树的知识结合，将后缀表达式转换为二叉树 [ 例子: a b c * + d e + - ]
		1.建立栈，大小为操作数个数，这里为5；
		2.将操作数从左到右入栈，若遇到操作符，则将前面两个元素弹出，并用当前栈顶指向形成的二叉树的根节点；
		3.最终合并二叉树。
	演示：
		1. a b c
		2. a 	    |
			    |
			   / \
			  b   c
		3.  		          +
					/   \
					a    *
					    / \
					   b   c
		4.  		  			          +				d e
								/   \
								a        *
									/ \
								   b   c
		5.  		  			  			          +		    +
											/   \		   / \
											a        *        d   e
												/ \
											   b   c
		6.									    		  	      -
														    /    \
														   /	  \		
														  /        \
														  +	    +
														/   \	   / \	 
														a    *    d   e    
															/ \		   
														   b   c	   
														   
## Coding时刻

* 栈的实现

接下来来实现栈，这里使用Java级数组来实现，当然，你也可以应该链表来搭建栈结构及其相关操作。

下面为要实现的操作方法API：
> Stack
```
public class Stack<T> {
    public Stack();
    public void push(T item);
    public boolean isEmpty();
    public int size();
}
```
在写出最终的实现代码之前，我们必须考虑应用数组或者其他形式来实现栈这种数据结构怎么样才能让其功能和性能最优。下面为重点考虑的几点：

> 1. 支持泛型。原因要使栈所支持的数据类型更加广泛通用，而不是需要String的时候写一遍栈的实现，再需要Integer类型的时候又重新写一遍针对Integer的实现。
>
> 2. 支持数组大小自动调节。对于数组来说，没法动态调节大小是一大缺点，随机查找是它的优势，若存入有效的元素过多导致数组容纳不下，或者存入有效元素很少（有可能为空）且数组大小较大，这些情况在实际应用当中都是非常不合理的，所以我们需要实现数组大小的动态调节。这里采用流行的调节方法，在数组容纳不下的时候将大小调节为原先的2倍，若数组的有效元素为数组的大小的1/4时将大小调节为原先的1/2。
>
> 3. 避免对象游离现象。Java的垃圾回收策略是回收所有无法被访问的对象的内存。在我们实现的栈当前，每一个pop弹出栈顶元素，栈顶指针向栈底移动一位（栈元素足够），但是实际这个被弹出的元素还存留在数组当前，也就是相应的占用这部分内存，GC无法回收。避免对象游离的办法其实很简单，在每次pop的时候将弹出的元素空间置为空。
>
> 4. 支持迭代。支持foreach迭代，可以使代码更加整洁。迭代器接口还需要实现remove方法，这个在实现的时候可以不处理，也可以抛出UnsupportedOperationException异常，在实现next方法时候栈为空，则可不处理或者抛出NoSuchElementException。

解决完以上考虑的问题，即可构建出一个不错的栈结构，具体代码实现：
```
import java.util.Iterator;//Java迭代器接口所属包

public class Stack<T> implements Iterable<T> {
    private T[] arr;
    private int len;

    public Stack() {//默认构造器
        arr = (T)new Object[1];//Java中不支持泛型对象数组 这里采用强制类型转换办法
        len = 0;//默认元素数量
    }

    public void push(T item) {//入栈
        if (arr.len == len) 
            resize(2 * arr.length);
        arr[len++] = item;
    }

    public T pop() {//出栈
        T t = arr[--len];
        arr[len] = null;//避免对象游离
        if (len > 0 && len == arr.length / 4)
            resize(arr.length / 2);
        return t;
    }

    public boolean isEmpty() {//检查栈是否为空
        return len == 0;
    }

    public int size() {//查看栈大小
        return len;
    }

    private void resize(int max) {//重新分配数组大小
        T[] t = (T[])new Object[max];
        for (int i = 0; i < len; i++) {
            t[i] = arr[i];
        }
        arr = t;
    }

    public Iterator<T> iterator() {
        return new ReverseArrayIterator();
    }

    private class ReverseArrayIterator implements Iterator<T> {//内部类，实现迭代器接口
        //支持先进后出迭代
        private int i = len;
        public boolean hasNext() { return i > 0; }
        public T next() { return arr[--i]; }
        public void remove { }
    }
} 
```

* Dijkstra算法 - 双栈算法表达式求值

使用两个栈来实现中缀表达式的求值，这里考虑的是理想情况，将所有运算都加上括号，输入为字符串的形式，实现加减乘除开方操作。基本的思路：
> 1. 将操作数压入操作数栈
>
> 2. 将操作符压入操作符栈
> 
> 3. 忽略左括号
>
> 4. 遇到右括号时，弹出一个运算符，弹出运算所需的操作数，并将运算完的结果压入操作数栈

具体代码实现：
```
public class DijkstraTwoStack {
    
    private Stack<Character> ops = new Stack<>();
    private Stack<Double> vals = new Stack<>();

    public DijkstraTwoStack {

    }

    public static int cal(String expr) {
        if (expr == null || expr.length <= 1) return 0;
        for (char c : expr) {
            if (c.equals('(')) ;
            else if (c.equals('+') || c.equals('-') || c.equals('*') || c.equals('/') || c.equals('s'))//用s表示开方 
                ops.push(c);
            else if (c.equals(')')) {
                char op = ops.pop();
                double v = vals.pop();
                if (op.equals('+')) v = vals.pop() + v;
                else if (op.equals('-')) v = vals.pop() - v;
                else if (op.equals('*')) v = vals.pop() * v;
                else if (op.equals('/')) v = vals.pop() / v;
                else if (op.equals('s')) v = Math.sqrt(v);
                vals.push(v);
            } else {
                vals.push(Double.parseDouble(c));//操作数字符转换为double类型入栈
            }
        }
    }
}
```

## 总结
本文以栈为中心，主要介绍了栈的应用及算术表达式在编程语言中的表达形式。栈在大数据结构中用处很广，在其他数据结构中也能作为很好
的辅助，比如迭代版的二叉树遍历、深度优先搜索和广度优先搜索等等。学好栈和队列的时候是算法设计的一大基础，务必要扎实学好。